# Cursor Rules for Document Generation Project

## Folder Structure and File Naming Conventions

- Use kebab-case for file and folder names (e.g., `user-profile.ts`, `api-endpoints/`)
- Organize code into logical folders:
  - `src/` - Main source code
  - `src/components/` - React components
  - `src/utils/` - Utility functions
  - `src/types/` - TypeScript type definitions
  - `src/api/` - API-related code
  - `test/` - All test files
  - `docs/` - Documentation
- Use descriptive, meaningful names that indicate purpose
- Group related files together in subdirectories

## TypeScript Best Practices

- Enable strict mode in `tsconfig.json`:
  ```json
  {
    "compilerOptions": {
      "strict": true,
      "noImplicitAny": true,
      "strictNullChecks": true,
      "strictFunctionTypes": true,
      "strictBindCallApply": true,
      "strictPropertyInitialization": true,
      "noImplicitReturns": true,
      "noFallthroughCasesInSwitch": true,
      "noUncheckedIndexedAccess": true,
      "exactOptionalPropertyTypes": true,
      "outDir": "./dist",
      "rootDir": "./src"
    }
  }
  ```
- Always define explicit return types for functions
- Use interfaces for object shapes, types for unions/primitives
- Prefer `const` over `let`, avoid `var`
- Use optional chaining (`?.`) and nullish coalescing (`??`)
- Define proper error types and handle them explicitly

## Linting Rules

- Use ESLint with recommended rules:
  ```json
  {
    "extends": [
      "eslint:recommended",
      "@typescript-eslint/recommended",
      "@typescript-eslint/recommended-requiring-type-checking"
    ],
    "rules": {
      "@typescript-eslint/no-unused-vars": "error",
      "@typescript-eslint/explicit-function-return-type": "warn",
      "@typescript-eslint/no-explicit-any": "error",
      "prefer-const": "error",
      "no-var": "error"
    }
  }
  ```
- Integrate Prettier for code formatting:
  ```json
  {
    "semi": true,
    "trailingComma": "es5",
    "singleQuote": true,
    "printWidth": 80,
    "tabWidth": 2
  }
  ```
- Run `eslint --fix` and `prettier --write` before commits

## Security Checks

- NEVER hard-code secrets, API keys, or sensitive data
- Use environment variables for all configuration:
  ```typescript
  // ✅ Correct
  const apiKey = process.env.API_KEY;
  const databaseUrl = process.env.DATABASE_URL;
  
  // ❌ Incorrect
  const apiKey = "sk-1234567890abcdef";
  ```
- Validate environment variables on startup
- Use `.env.example` to document required environment variables
- Add `.env` to `.gitignore`
- Sanitize user inputs and use parameterized queries
- Implement proper authentication and authorization

## Dependency Management

- Remove unused imports immediately
- Use `npm audit` to check for security vulnerabilities
- Keep dependencies up to date with `npm update`
- Use exact versions in `package-lock.json`
- Document major dependency changes in commit messages
- Use `npm ci` in CI/CD pipelines for reproducible builds

## Testing Requirements

- Maintain ≥80% code coverage
- Place all tests in `test/` folder
- Use descriptive test names that explain the scenario
- Test both success and error cases
- Mock external dependencies
- Use test data factories for consistent test data
- Run tests before every commit
- Example test structure:
  ```
  test/
  ├── unit/
  ├── integration/
  ├── e2e/
  └── fixtures/
  ```

## Commit Message Format

Use conventional commits format:
- `feat:` - New features
- `fix:` - Bug fixes
- `docs:` - Documentation changes
- `style:` - Code style changes (formatting, etc.)
- `refactor:` - Code refactoring
- `test:` - Adding or updating tests
- `chore:` - Maintenance tasks

Examples:
```
feat: add user authentication system
fix: resolve API endpoint timeout issue
docs: update README with setup instructions
chore: update dependencies to latest versions
```

## CI/CD Integration

- Run the following checks on every PR:
  ```yaml
  - name: Lint
    run: npm run lint
  
  - name: Type check
    run: npm run type-check
  
  - name: Build
    run: npm run build
  
  - name: Test
    run: npm run test:coverage
  
  - name: Security audit
    run: npm audit
  ```
- Require all checks to pass before merging
- Enforce branch protection rules
- Use semantic versioning for releases
- Automate deployment on successful merge to main

## Code Review Guidelines

- Review for security vulnerabilities
- Check for proper error handling
- Ensure tests cover new functionality
- Verify TypeScript types are correct
- Confirm code follows established patterns
- Check for performance implications
- Validate documentation is updated

## Performance Considerations

- Use lazy loading for large components
- Implement proper caching strategies
- Optimize bundle size with tree shaking
- Use React.memo for expensive components
- Implement proper error boundaries
- Monitor and optimize database queries

## Documentation Standards

- Document all public APIs
- Include JSDoc comments for complex functions
- Maintain up-to-date README files
- Document environment variables
- Include setup and deployment instructions
- Keep changelog updated

Remember: These rules are enforced to maintain code quality, security, and maintainability. Follow them consistently across the project. 